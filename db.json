{"meta":{"version":1,"warehouse":"1.0.3"},"models":{"Asset":[{"_id":"source/images/avatar.jpg","path":"images/avatar.jpg","modified":1}],"Cache":[{"_id":"source/_posts/Java-io.md","shasum":"2c9a75dd34010aaff9019c0cace91fe2c5c2c1b1","modified":1454947083434},{"_id":"source/_posts/JavaFx-Property-and-Bindings.md","shasum":"5882bd1270356b4249298c938c1138d316f6ebcf","modified":1454947083434},{"_id":"source/_posts/PythonLearning1.md","shasum":"c02fd87d27d750fdf5e0aa3fec5f5c2dd566539d","modified":1454947083434},{"_id":"source/_posts/R-language.md","shasum":"53378deb6c2972ae97874117f433936ad03c055c","modified":1454947083434},{"_id":"source/_posts/Text Justification.md","shasum":"4a2d7025bcf51e24810dc94a900b3ac755c110de","modified":1454947413648},{"_id":"source/_posts/docker.md","shasum":"c8e4cde80499462386586aa7043cce3657cdfb47","modified":1454947083434},{"_id":"source/_posts/git上传.md","shasum":"1237047ae23b8ea2426fb4b56cfe0bdcd42cd9d5","modified":1454948166283},{"_id":"source/_posts/linux.md","shasum":"78963d9d1f688468e97401f481f79ebd9cfdbc51","modified":1454947083434},{"_id":"source/_posts/ml-index.md","shasum":"de96d911c22eba359d9c23411260087b598043cd","modified":1454947083434},{"_id":"source/_posts/ml1","shasum":"815de1c16eb9b2ea71c3e41abac75ce8bb743431","modified":1454947083434},{"_id":"source/_posts/operating system.md","shasum":"0eba4f6bee98f5467bfc4371b1d87cadeaf886ea","modified":1454947083434},{"_id":"source/_posts/sorting.md","shasum":"bb5718386461600261ee7dfe987645b7fc77573f","modified":1454947083434},{"_id":"source/_posts/tar常用命令.md","shasum":"dabfc90e8b7c41c394295cc22765c792d63e58e8","modified":1454948642922},{"_id":"source/_posts/一-点-点-想-法.md","shasum":"28d67bc6ad5b1fc8f541fe5ea142161b14dc822c","modified":1454947083434},{"_id":"source/_posts/写-在-看-书-之-前.md","shasum":"0cd05728873801b26e902f33d0f2b5f885359173","modified":1454947083434},{"_id":"source/_posts/暑-期-书-单.md","shasum":"39a493055917996674ef1676b4194abf58aaee53","modified":1454947083434},{"_id":"source/about/index.md","shasum":"95a5ae5ce73d0bb7a876037b6bb2c571ba2c7763","modified":1454947083434},{"_id":"source/categories/index.md","shasum":"4f04a429a5dd7dd98bfb4118b47845630c62a5dc","modified":1454947083434},{"_id":"source/images/avatar.jpg","shasum":"1ba6bc7054e971cfbe5805ddf1ae50c0add34e5d","modified":1454947083434},{"_id":"source/tags/index.md","shasum":"d3f904dd989f93db080a49718e6490c2cefa9fb8","modified":1454947083434}],"Category":[{"name":"note","_id":"cike71t360001bya1qtjbqwq6"},{"name":"杂七杂八","_id":"cike71t3n0009bya1uj2ulqnm"},{"name":"Be My Hero","_id":"cike71t3y000kbya19q5jatcq"}],"Data":[],"Page":[{"title":"tags","date":"2016-02-03T11:48:43.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2016-02-03 19:48:43\ntype: \"tags\"\ncomments: false\n---\n","updated":"2016-02-08T15:58:03.434Z","path":"tags/index.html","layout":"page","_id":"cike71t3d0005bya1wfce3m48"},{"title":"categories","date":"2016-02-03T12:11:32.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2016-02-03 20:11:32\ntype: \"categories\"\ncomments: false\n---\n","updated":"2016-02-08T15:58:03.434Z","path":"categories/index.html","layout":"page","_id":"cike71t3f0006bya18hjkkhtp"},{"title":"about","date":"2016-02-03T08:35:27.000Z","comments":0,"_content":"welcome to sea's home\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2016-02-03 16:35:27\ncomments: false\n---\nwelcome to sea's home\n","updated":"2016-02-08T15:58:03.434Z","path":"about/index.html","layout":"page","_id":"cike71t3j0007bya1n3hfokll"}],"Post":[{"layout":"post","title":"输入/输出","date":"2015-07-03T16:00:00.000Z","_content":"### 输入/输出\n1. 文件系统和路径\n2. 文件和目录的处理及操作\n3. 输入/输出流  \n4. 读取二进制数据  \n5. 写入二进制数据  \n6. 写入文本  \n7. 读取文本  \n8. 用PrintStream记录日志  \n9. 随机访问文件  \n10. 对象序列化  \n\n#### 1.文件系统和路径  \n1. 文件系统中的对象可以用一条路径作为惟一的识别  \n2. 路径分为绝对路径和相对路径\n3. 文件或者目录一般用java.io.File对象表示，java7中，用java.nio.file.Path接口代替它   \n\n> FileSystem类 :\n\n  >  - `FileSystems.getDefault()`获取当前的文件系统   \n  >  - `getSeparator()`获取当前系统的分隔符   \n  >  - `getRootDirectories()`返回一个Iterable,遍历根目录     \n4. 创建path\n    1. `FileSystems.getPath(...)`  \n    2. `Path path = Paths.get(...)`\n    3. `getNameCount()`,`getName(int index)`从0开始\n    4. path其他方法`getFileName()`,`getParent()`,`getRoot()`\n\n#### 2.文件和目录的处理及操作\n1. 创建和删除文件及目录   \n   `createFile()`,`createDirectory()`,`delete()`,`deleteIfExists()`,如果用`delteIfExists()`删除目录，则目录必须为空\n2. 获取目录的对象  \n   使用newDirectoryStream()方法,`public static DirectoryStream<Path> newDirectoryStream(Path path)`  \n\n   ---\n   >  代码实例：\n\n    >\t    Path parent = Paths.get(\"/home/simple_chen/下载\");\n        \ttry (DirectoryStream<Path> children = Files.newDirectoryStream(parent)){\n        \t  for (Path child : children) {\n           \t  System.out.println(child);\n              }\n            } catch (IOException e) {\n             \t\te.printStackTrace();\n            }   \n   ---        \n\n3. 复制和文件移动   \n     1. 复制\n       `public static Path copy(Path source, Path target, CopyOption...options) throws java.io.IOException`   \n       CopyOption是java.nio.file包的一个接口。`StandardCopyOption`是CopyOption接口的一个实现。  \n       StandardCopyOption有三个复制选项:\n        - ATOMIC_MOVE  \n        - COPY_ATTRIBUTES   \n        - REPLACE_EXISTING  \n     2. 移动\n        `public static Path move(Path source, Path target, CopyOption...options) throws java.io.IOException`   \n4. 文件读取和写入\n    对于较小的文件，File类提供了从二进制文件和文本文件读取和写入的方法\n    - 二进制  \n    `public static byte[] readAllBytes(Path path) throws java.io.IOException`  \n    `public static write(Path path, byte[] bytes, OpenOption...options) throws java.io.IOException`\n    - 文本文件  \n    `public static List<String> readAllLines(Path path, java.nio.charset.Charset charset) throws java.io.IOException`\n    `public static write(Path path, java.lang.Iterable<? extends CharSequence> lines, java.nio.charset.Charset charset, OpenOption...options) throws java.io.IOException`  \n\n    >  这两个方法都重载了OpenOption,第二个方法还重载了一个Charset  \t\n    >  \t\t\n    - StandardOpenOption实现了OpenOption接口:  \n      -  APPEND  \n      -  CREATE  \n      -  CREATE_NEW  \n      -  DELETE_ON_CLOSE   \n      -  DSYNC  \n      -  READ  \n      -  SPARSE  \n      -  SYNC  \n      -  TRUNCATE_EXISTING  \n      -  WRITE   \n\n    >    - java.nio.charset.Charset是一个表示字符集的抽象类。需要指定在将**字符编码成字节**和将**字节解码成字符**时要使用的字符集。\n    创建一个charset   \n    `Charset usAscii = Charset.forName(\"US-ASCII\")`    \n\n    > ***代码实例:***  \n    >\t\t         \n        \tPath textfile = Paths.get(\"/home/simple_chen/textfile\");\n        \tCharset charset = Charset.forName(\"US-ASCII\");\n        \tString line1 = \"Easy read and write\";\n        \tString line2 = \"Easy read and write\";\n        \tList<String> lines = Arrays.asList(line1,line2);\n        \ttry {\n            \tFiles.write(textfile,lines,charset);\n        \t} catch (IOException e) {\n            \te.printStackTrace();\n        \t}  \n    >\n        \tList<String> linesRead = null;\n        \ttry {\n            \tlinesRead = Files.readAllLines(textfile, charset);\n        \t} catch (IOException e) {\n            \te.printStackTrace();\n        \t}  \n    >\n        \tif(linesRead != null) {\n            \tfor (String str : linesRead) {\n                \tSystem.out.println(str);\n            \t}\n        \t}\t   \n\n#### 3. 输入/输出流\n1. What is Stream?  \n个人理解：用一种统一的方式使的数据在不同的接收装置中传输的机制吧。打个比方，流就是管道，接收装置就是一个个“水库”，而管道将各个水库连接起来。\n2. 流的分类  \n   根据数据流向，可分为输入流和输出流，而数据又可以分为二进制数据和字符，因此每种又可分为两种，即：\n\t\t\t- Reader: 从一个接收装置中读取字符的流\n\t\t\t- Writer: 将一个字符写入一个接收装置的流\n\t\t\t- InputStream: 从一个接收装置中读取二进制数据的流\n\t\t\t- OutputStream: 将二进制数据写入到一个接收装置的流\t\t\n3. 流的一般操作顺序：\n\t\t\t1. 创建一个流。得到的对象已经处于打开状态，因此没有open方法可以调用\n\t\t\t2. 执行读取或者写入操作\n\t\t\t3. 通过调用close方法关闭流。由于当前大多数流都实现了java.lang.AutoCloseable接口，因此可以利用try-with-resources语句创建一个流，并且让流自动关闭\n4. 使用流的好处\n \t\t\t1. 为数据的读取和写入定义了方法，无论数据源还是数据目标都可以使用。\n \t\t\t2. 为了连接一个专门的接收装置，利用java.nio.file.Files类提供的方法，正确构造流即可。\n\n#### 4. 读取二进制数据\n","source":"_posts/Java-io.md","raw":"---\nlayout: post\ntitle: 输入/输出\ndate: 2015-07-04\ntags: Java\ncategories: note\n---\n### 输入/输出\n1. 文件系统和路径\n2. 文件和目录的处理及操作\n3. 输入/输出流  \n4. 读取二进制数据  \n5. 写入二进制数据  \n6. 写入文本  \n7. 读取文本  \n8. 用PrintStream记录日志  \n9. 随机访问文件  \n10. 对象序列化  \n\n#### 1.文件系统和路径  \n1. 文件系统中的对象可以用一条路径作为惟一的识别  \n2. 路径分为绝对路径和相对路径\n3. 文件或者目录一般用java.io.File对象表示，java7中，用java.nio.file.Path接口代替它   \n\n> FileSystem类 :\n\n  >  - `FileSystems.getDefault()`获取当前的文件系统   \n  >  - `getSeparator()`获取当前系统的分隔符   \n  >  - `getRootDirectories()`返回一个Iterable,遍历根目录     \n4. 创建path\n    1. `FileSystems.getPath(...)`  \n    2. `Path path = Paths.get(...)`\n    3. `getNameCount()`,`getName(int index)`从0开始\n    4. path其他方法`getFileName()`,`getParent()`,`getRoot()`\n\n#### 2.文件和目录的处理及操作\n1. 创建和删除文件及目录   \n   `createFile()`,`createDirectory()`,`delete()`,`deleteIfExists()`,如果用`delteIfExists()`删除目录，则目录必须为空\n2. 获取目录的对象  \n   使用newDirectoryStream()方法,`public static DirectoryStream<Path> newDirectoryStream(Path path)`  \n\n   ---\n   >  代码实例：\n\n    >\t    Path parent = Paths.get(\"/home/simple_chen/下载\");\n        \ttry (DirectoryStream<Path> children = Files.newDirectoryStream(parent)){\n        \t  for (Path child : children) {\n           \t  System.out.println(child);\n              }\n            } catch (IOException e) {\n             \t\te.printStackTrace();\n            }   \n   ---        \n\n3. 复制和文件移动   \n     1. 复制\n       `public static Path copy(Path source, Path target, CopyOption...options) throws java.io.IOException`   \n       CopyOption是java.nio.file包的一个接口。`StandardCopyOption`是CopyOption接口的一个实现。  \n       StandardCopyOption有三个复制选项:\n        - ATOMIC_MOVE  \n        - COPY_ATTRIBUTES   \n        - REPLACE_EXISTING  \n     2. 移动\n        `public static Path move(Path source, Path target, CopyOption...options) throws java.io.IOException`   \n4. 文件读取和写入\n    对于较小的文件，File类提供了从二进制文件和文本文件读取和写入的方法\n    - 二进制  \n    `public static byte[] readAllBytes(Path path) throws java.io.IOException`  \n    `public static write(Path path, byte[] bytes, OpenOption...options) throws java.io.IOException`\n    - 文本文件  \n    `public static List<String> readAllLines(Path path, java.nio.charset.Charset charset) throws java.io.IOException`\n    `public static write(Path path, java.lang.Iterable<? extends CharSequence> lines, java.nio.charset.Charset charset, OpenOption...options) throws java.io.IOException`  \n\n    >  这两个方法都重载了OpenOption,第二个方法还重载了一个Charset  \t\n    >  \t\t\n    - StandardOpenOption实现了OpenOption接口:  \n      -  APPEND  \n      -  CREATE  \n      -  CREATE_NEW  \n      -  DELETE_ON_CLOSE   \n      -  DSYNC  \n      -  READ  \n      -  SPARSE  \n      -  SYNC  \n      -  TRUNCATE_EXISTING  \n      -  WRITE   \n\n    >    - java.nio.charset.Charset是一个表示字符集的抽象类。需要指定在将**字符编码成字节**和将**字节解码成字符**时要使用的字符集。\n    创建一个charset   \n    `Charset usAscii = Charset.forName(\"US-ASCII\")`    \n\n    > ***代码实例:***  \n    >\t\t         \n        \tPath textfile = Paths.get(\"/home/simple_chen/textfile\");\n        \tCharset charset = Charset.forName(\"US-ASCII\");\n        \tString line1 = \"Easy read and write\";\n        \tString line2 = \"Easy read and write\";\n        \tList<String> lines = Arrays.asList(line1,line2);\n        \ttry {\n            \tFiles.write(textfile,lines,charset);\n        \t} catch (IOException e) {\n            \te.printStackTrace();\n        \t}  \n    >\n        \tList<String> linesRead = null;\n        \ttry {\n            \tlinesRead = Files.readAllLines(textfile, charset);\n        \t} catch (IOException e) {\n            \te.printStackTrace();\n        \t}  \n    >\n        \tif(linesRead != null) {\n            \tfor (String str : linesRead) {\n                \tSystem.out.println(str);\n            \t}\n        \t}\t   \n\n#### 3. 输入/输出流\n1. What is Stream?  \n个人理解：用一种统一的方式使的数据在不同的接收装置中传输的机制吧。打个比方，流就是管道，接收装置就是一个个“水库”，而管道将各个水库连接起来。\n2. 流的分类  \n   根据数据流向，可分为输入流和输出流，而数据又可以分为二进制数据和字符，因此每种又可分为两种，即：\n\t\t\t- Reader: 从一个接收装置中读取字符的流\n\t\t\t- Writer: 将一个字符写入一个接收装置的流\n\t\t\t- InputStream: 从一个接收装置中读取二进制数据的流\n\t\t\t- OutputStream: 将二进制数据写入到一个接收装置的流\t\t\n3. 流的一般操作顺序：\n\t\t\t1. 创建一个流。得到的对象已经处于打开状态，因此没有open方法可以调用\n\t\t\t2. 执行读取或者写入操作\n\t\t\t3. 通过调用close方法关闭流。由于当前大多数流都实现了java.lang.AutoCloseable接口，因此可以利用try-with-resources语句创建一个流，并且让流自动关闭\n4. 使用流的好处\n \t\t\t1. 为数据的读取和写入定义了方法，无论数据源还是数据目标都可以使用。\n \t\t\t2. 为了连接一个专门的接收装置，利用java.nio.file.Files类提供的方法，正确构造流即可。\n\n#### 4. 读取二进制数据\n","slug":"Java-io","published":1,"updated":"2016-02-08T15:58:03.434Z","comments":1,"photos":[],"link":"","_id":"cike71t300000bya1r7ajrj50"},{"layout":"post","title":"七月八月书单","date":"2015-07-15T16:00:00.000Z","_content":"### 暑期书单\n- ![dive into python3](../img/book/bdiveintopython.jpg \"dive into python3\")\n\n- ![机器学习](../img/book/bml.jpg \"机器学习\")  \n  入门书籍\n\n- ![机器学习实战](../img/book/bmla.jpg \"机器学习实战\")\n\n- ![统计学习方法](../img/book/bmsl.jpg \"统计学习方法\")  \n  与上一本书结合起来看  \n\n- ![算法](../img/book/balgorithm.jpg \"算法\")  \n\t- 复习\n\t- 做习题\n","source":"_posts/暑-期-书-单.md","raw":"---\nlayout: post\ntitle: 七月八月书单\ndate: 2015-07-16\ntags: 书单\ncategories: 杂七杂八\n---\n### 暑期书单\n- ![dive into python3](../img/book/bdiveintopython.jpg \"dive into python3\")\n\n- ![机器学习](../img/book/bml.jpg \"机器学习\")  \n  入门书籍\n\n- ![机器学习实战](../img/book/bmla.jpg \"机器学习实战\")\n\n- ![统计学习方法](../img/book/bmsl.jpg \"统计学习方法\")  \n  与上一本书结合起来看  \n\n- ![算法](../img/book/balgorithm.jpg \"算法\")  \n\t- 复习\n\t- 做习题\n","slug":"暑-期-书-单","published":1,"updated":"2016-02-08T15:58:03.434Z","comments":1,"photos":[],"link":"","_id":"cike71t3l0008bya1nwgsrb5n"},{"layout":"post","title":"写在看书之前","date":"2015-12-11T16:00:00.000Z","_content":"\n## 写在看书之前\n对于技术资料，学习之前头脑里一定要有一个概念，或者说是一个框架，即：\n\n1. 这部分在讲什么\n2. 我想知道什么\n3. 这部分讲解的大致结构是怎样的\n\n看书要求：\n\n1. 有笔，有纸\n2. 先总览后，画出大致的框架\n3. 针对每一部分再画出框架\n4. 经常问自己这块是在讲什么\n\n总而言之就是一定知道自己目前在看什么\n","source":"_posts/写-在-看-书-之-前.md","raw":"---\nlayout: post\ntitle: 写在看书之前\ndate: 2015-12-12\ntags: 随笔\n---\n\n## 写在看书之前\n对于技术资料，学习之前头脑里一定要有一个概念，或者说是一个框架，即：\n\n1. 这部分在讲什么\n2. 我想知道什么\n3. 这部分讲解的大致结构是怎样的\n\n看书要求：\n\n1. 有笔，有纸\n2. 先总览后，画出大致的框架\n3. 针对每一部分再画出框架\n4. 经常问自己这块是在讲什么\n\n总而言之就是一定知道自己目前在看什么\n","slug":"写-在-看-书-之-前","published":1,"updated":"2016-02-08T15:58:03.434Z","comments":1,"photos":[],"link":"","_id":"cike71t3p000dbya1kz1j061r"},{"layout":"post","title":"一点点想法（1）","date":"2015-07-26T16:00:00.000Z","_content":"\n想学ML,又想适当做些项目，其实不矛盾。适当的做项目可以让我很快实现模型，将更多的精力花在思考研究算法上。数学、线代、概率论是基础，即使不是从头啃一遍，但也要经常翻经常看\nML的确看得很痛苦，但只是第一步，坚持下去就好了，加油！\n","source":"_posts/一-点-点-想-法.md","raw":"---\nlayout: post\ntitle: 一点点想法（1）\ndate: 2015-07-27\ntags: 随笔\ncategories: 杂七杂八\n---\n\n想学ML,又想适当做些项目，其实不矛盾。适当的做项目可以让我很快实现模型，将更多的精力花在思考研究算法上。数学、线代、概率论是基础，即使不是从头啃一遍，但也要经常翻经常看\nML的确看得很痛苦，但只是第一步，坚持下去就好了，加油！\n","slug":"一-点-点-想-法","published":1,"updated":"2016-02-08T15:58:03.434Z","comments":1,"photos":[],"link":"","_id":"cike71t3s000gbya1u3m0zbk9"},{"layout":"post","title":"tar常用命令","date":"2016-02-07T16:00:00.000Z","_content":"\n打包\ntar -czf fileFolder.tar.gz fileFolder\n解包\ntar -xvf fileFolder.tar.gz\n\n.tar.gz压缩\ntar zcvf fileName.tar.gz fileFolder\n.tar.gz解压\ntar -zxvf fileName.tar.gz\n\n.tar.bz2压缩\ntar jcvf fileName.tar.bz2 fileFolder\n.tar.bz2解压\ntar jxvf fileName.tar.bz2\n","source":"_posts/tar常用命令.md","raw":"---\nlayout: post\ntitle: tar常用命令\ndate: 2016-02-08\ntags: tar\ncategories: Be My Hero\n---\n\n打包\ntar -czf fileFolder.tar.gz fileFolder\n解包\ntar -xvf fileFolder.tar.gz\n\n.tar.gz压缩\ntar zcvf fileName.tar.gz fileFolder\n.tar.gz解压\ntar -zxvf fileName.tar.gz\n\n.tar.bz2压缩\ntar jcvf fileName.tar.bz2 fileFolder\n.tar.bz2解压\ntar jxvf fileName.tar.bz2\n","slug":"tar常用命令","published":1,"updated":"2016-02-08T16:24:02.922Z","comments":1,"photos":[],"link":"","_id":"cike71t3x000jbya11mybcph6"},{"layout":"post","title":"排序整理","date":"2015-06-21T16:00:00.000Z","categorys":"note","_content":"\n\n>  《算法》第四版复习整理（c语言）\n\n\tvoid swap(int &i, int &j)\n\t{\n\t\tint temp = i;\n\t\ti = j;\n\t\tj = temp;\n\t}    \n\n## 冒泡排序   \n\tvoid BubbleSort(int a[], int n)\n\t{\n\t\tfor(int i = 0; i < n; i++)  \n\t\t\tfor (int j = 1; j < n - i; ++j)  \n\t\t\t{\n\t\t\t\tif(a[j-1] > a[j])\n\t\t\t\t{\n\t\t\t\t\tswap(a[j-1],a[j]);\n\t\t\t\t}\n\t\t\t}\n\t}\n\n\n## 选择排序\n```\n\tvoid SelectSort(int a[], int n)\n\t{\n\t\tint i,j,min;\n\t\tint temp;\n\t\tfor (i = 0; i < n; ++i)\n\t\t{\n\t\t\tmin = i;\n\t\t\tfor (j = i+1; j < n; ++j)\n\t\t\t{\n\t\t\t\tif (a[min] > a[j])\n\t\t\t\tmin = j;\n\t\t\t}\n\t\t\tswap(a[i],a[min]);\n\t\t}\n\t}\n```\n\n## 插入排序   \n```\n\tvoid InsertSort(int a[], int n)\n\t{\n\t\tint i,j;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tfor (int j = i; j > 0 && (a[j] < a[j-1]) ; --j)\n\t\t\tswap(a[j],a[j-1]);\n\t\t}\n\t}\n```\n## 希尔排序   \n```\n\tvoid ShellSort(int a[], int n)\n\t{\n\t\tint h = 1;\n\t\tint i,j;\n\t\twhile(h < n/3)\n\t\th = 3*h + 1;\n\t\twhile(h >= 1)\n\t\t{\n\t\t\tfor (i = h; i < n; ++i)\n\t\t\t{\n\t\t\t\tfor (j = i; j >= h && (a[j] < a[j-h]); j -= h)\n\t\t\t\tswap(a[j],a[j-h]);\n\t\t\t}\n\t\t\th = h/3;\n\t\t}\n\t}\n```\n\n\n## 快速排序\n\n### 1 edition   \n```\n\t\tvoid QuickSort(int v[], int left, int right)\n\t\t{\n\t\t\tint i, last;\n\t\t\tif (left >= right)\n\t\t\t\treturn;\n\t\t\tswap(v[left], v[(left+right)/2]);\n\t\t\t\tlast = left;\n\t\t\tfor (i = 0; i < right; ++i)\n\t\t\t\tif (v[i] < v[left])\n\t\t\t\t\tswap(++last, i);\n\t\t\tswap(left,last);\n\t\t\tQuickSort(v,left,last-1);\n\t\t\tQuickSort(v,last+1,right);\n\t\t}  \n```\n### 2 edition  \n```\n    \tvoid QuickSort(int a[], int n)\n    \t{\n    \t\t//1.random shuffle 消除对输入的依赖\n    \t\t//2.Sort(a,0,n-1);\n   \t \t}\n\n    \tvoid Sort(int a[], int lo, int hi)\n    \t{\n    \t\tif (hi > lo)\n    \t\t{\n    \t\t\tint j = partition(a, lo, hi);\n    \t\t\tsort(a, lo, j-1);\n    \t\t\tsort(a, j+1, hi);\n    \t\t}\n    \t}\n\n    \tint partition(int a[], int lo, int hi)\n    \t{\n       \t\t// hi + 1 是一个技巧\n       \t\tint i = lo, j = hi+1;\n       \t\tint v = a[lo];\n       \t\twhile(true)\n       \t\t{\n       \t\twhile (a[++i] < v)\n       \t\tif (i == hi)\n       \t\tbreak;\n       \t\twhile (v < a[--j])\n       \t\tif (j == lo)\n       \t\tbreak;\n       \t\tif (i >= j)\n       \t\tbreak;\n       \t\tswap(a[i],a[j]);\n        \t}\n       \t\tswap(a[lo],a[j]);\n       \t\treturn j;\n    \t}\n```\n### 3 edition  \n```\n    \tvoid QuickSort(int a[], int lo, int hi)\n    \t{\n    \t\tint i = lo, j = hi;\n    \t\tint temp;\n    \t\tif (hi > lo)\n    \t\t{\n    \t\t\ttemp = a[lo];\n    \t\t\twhile (i != j)\n    \t\t\t{\n    \t\t\t\twhile (j > i && a[j] >= temp)\n    \t\t\t\t{\n    \t\t\t\tj--;\n    \t\t\t\t}\n    \t\t\t\ta[i] = a[j];\n    \t\t\t\twhile (i < j && a[i] <= temp)\n    \t\t\t\t{\n    \t\t\t\t\ti++;\n    \t\t\t\t}\n    \t\t\t\ta[j] = a[i];\n\t\t\t\t}\n\t\t\t\ta[i] = temp;\n\t\t\t\tQuickSort(a, lo , i - 1);\n\t\t\t\tQuickSort(a, i + 1, hi);\n    \t\t}\n    \t}\n```\n> 版本2和版本3的区别在于，版本2的是让两边同时进行比较，在两边都不符合条件的情况下交换，直至i和j相等。版本3若是右边一边比较不符合条件，则移至另一边比较，直至i和j相等。\n\n## 归并排序\n```\n    bool MergeSort(int a[], int n);\n    {\n       int aux[n];\n \t   sort(a,0,n-1,aux);\n \t   return true;\n    }\n\n    //自底向下\n    void Sort(int a[], int lo, int hi,int aux[])\n    {\n       if (hi > lo)\n       {\n       \t  int mid = lo + (hi - lo)/2;\n       \t  Sort(a, lo, mid);\n       \t  Sort(a, mid+1, hi);\n       \t  Merge(a, lo, mid, hi, aux);\n       }\n    }\n\n    //自底向上\n    void Sort(int a[], int n, int aux)\n    {\n       for(int sz = 1; sz < n; sz = sz + sz)\n          for(int lo = 0; lo < n - sz; lo += sz+sz)\n            // c语言没有min函数\n             Merge(a, lo, lo+sz-1; Math.min(lo+sz+sz-1, n-1));\n    }\n\n\tvoid Merge (int a[], int lo, int mid, int hi, int aux[])\n\t{\n\t\tint i = lo, j = mid + 1;\n\t\t//辅助变量\n\t\tint k;\n\t\tfor(k = lo; k <= hi; k++)\n\t\t{\n\t\t\taux[k] = a[k];\n\t\t}\n\n\t\tfor (k = lo; k <= hi; k++)\n\t\t\tif      (i > mid)           a[k] = aux[j++];\n\t\t\telse if (j > hi )           a[k] = aux[i++];\n\t\t\telse if (aux[j] < aux[i])   a[k] = aux[j++];\n\t\t\telse                        a[k] = aux[i++];\n\t}\n```\n","source":"_posts/sorting.md","raw":"---\nlayout: post\ntitle: 排序整理\ndate: 2015-06-22\ntags: 算法\ncategorys: note\n---\n\n\n>  《算法》第四版复习整理（c语言）\n\n\tvoid swap(int &i, int &j)\n\t{\n\t\tint temp = i;\n\t\ti = j;\n\t\tj = temp;\n\t}    \n\n## 冒泡排序   \n\tvoid BubbleSort(int a[], int n)\n\t{\n\t\tfor(int i = 0; i < n; i++)  \n\t\t\tfor (int j = 1; j < n - i; ++j)  \n\t\t\t{\n\t\t\t\tif(a[j-1] > a[j])\n\t\t\t\t{\n\t\t\t\t\tswap(a[j-1],a[j]);\n\t\t\t\t}\n\t\t\t}\n\t}\n\n\n## 选择排序\n```\n\tvoid SelectSort(int a[], int n)\n\t{\n\t\tint i,j,min;\n\t\tint temp;\n\t\tfor (i = 0; i < n; ++i)\n\t\t{\n\t\t\tmin = i;\n\t\t\tfor (j = i+1; j < n; ++j)\n\t\t\t{\n\t\t\t\tif (a[min] > a[j])\n\t\t\t\tmin = j;\n\t\t\t}\n\t\t\tswap(a[i],a[min]);\n\t\t}\n\t}\n```\n\n## 插入排序   \n```\n\tvoid InsertSort(int a[], int n)\n\t{\n\t\tint i,j;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tfor (int j = i; j > 0 && (a[j] < a[j-1]) ; --j)\n\t\t\tswap(a[j],a[j-1]);\n\t\t}\n\t}\n```\n## 希尔排序   \n```\n\tvoid ShellSort(int a[], int n)\n\t{\n\t\tint h = 1;\n\t\tint i,j;\n\t\twhile(h < n/3)\n\t\th = 3*h + 1;\n\t\twhile(h >= 1)\n\t\t{\n\t\t\tfor (i = h; i < n; ++i)\n\t\t\t{\n\t\t\t\tfor (j = i; j >= h && (a[j] < a[j-h]); j -= h)\n\t\t\t\tswap(a[j],a[j-h]);\n\t\t\t}\n\t\t\th = h/3;\n\t\t}\n\t}\n```\n\n\n## 快速排序\n\n### 1 edition   \n```\n\t\tvoid QuickSort(int v[], int left, int right)\n\t\t{\n\t\t\tint i, last;\n\t\t\tif (left >= right)\n\t\t\t\treturn;\n\t\t\tswap(v[left], v[(left+right)/2]);\n\t\t\t\tlast = left;\n\t\t\tfor (i = 0; i < right; ++i)\n\t\t\t\tif (v[i] < v[left])\n\t\t\t\t\tswap(++last, i);\n\t\t\tswap(left,last);\n\t\t\tQuickSort(v,left,last-1);\n\t\t\tQuickSort(v,last+1,right);\n\t\t}  \n```\n### 2 edition  \n```\n    \tvoid QuickSort(int a[], int n)\n    \t{\n    \t\t//1.random shuffle 消除对输入的依赖\n    \t\t//2.Sort(a,0,n-1);\n   \t \t}\n\n    \tvoid Sort(int a[], int lo, int hi)\n    \t{\n    \t\tif (hi > lo)\n    \t\t{\n    \t\t\tint j = partition(a, lo, hi);\n    \t\t\tsort(a, lo, j-1);\n    \t\t\tsort(a, j+1, hi);\n    \t\t}\n    \t}\n\n    \tint partition(int a[], int lo, int hi)\n    \t{\n       \t\t// hi + 1 是一个技巧\n       \t\tint i = lo, j = hi+1;\n       \t\tint v = a[lo];\n       \t\twhile(true)\n       \t\t{\n       \t\twhile (a[++i] < v)\n       \t\tif (i == hi)\n       \t\tbreak;\n       \t\twhile (v < a[--j])\n       \t\tif (j == lo)\n       \t\tbreak;\n       \t\tif (i >= j)\n       \t\tbreak;\n       \t\tswap(a[i],a[j]);\n        \t}\n       \t\tswap(a[lo],a[j]);\n       \t\treturn j;\n    \t}\n```\n### 3 edition  \n```\n    \tvoid QuickSort(int a[], int lo, int hi)\n    \t{\n    \t\tint i = lo, j = hi;\n    \t\tint temp;\n    \t\tif (hi > lo)\n    \t\t{\n    \t\t\ttemp = a[lo];\n    \t\t\twhile (i != j)\n    \t\t\t{\n    \t\t\t\twhile (j > i && a[j] >= temp)\n    \t\t\t\t{\n    \t\t\t\tj--;\n    \t\t\t\t}\n    \t\t\t\ta[i] = a[j];\n    \t\t\t\twhile (i < j && a[i] <= temp)\n    \t\t\t\t{\n    \t\t\t\t\ti++;\n    \t\t\t\t}\n    \t\t\t\ta[j] = a[i];\n\t\t\t\t}\n\t\t\t\ta[i] = temp;\n\t\t\t\tQuickSort(a, lo , i - 1);\n\t\t\t\tQuickSort(a, i + 1, hi);\n    \t\t}\n    \t}\n```\n> 版本2和版本3的区别在于，版本2的是让两边同时进行比较，在两边都不符合条件的情况下交换，直至i和j相等。版本3若是右边一边比较不符合条件，则移至另一边比较，直至i和j相等。\n\n## 归并排序\n```\n    bool MergeSort(int a[], int n);\n    {\n       int aux[n];\n \t   sort(a,0,n-1,aux);\n \t   return true;\n    }\n\n    //自底向下\n    void Sort(int a[], int lo, int hi,int aux[])\n    {\n       if (hi > lo)\n       {\n       \t  int mid = lo + (hi - lo)/2;\n       \t  Sort(a, lo, mid);\n       \t  Sort(a, mid+1, hi);\n       \t  Merge(a, lo, mid, hi, aux);\n       }\n    }\n\n    //自底向上\n    void Sort(int a[], int n, int aux)\n    {\n       for(int sz = 1; sz < n; sz = sz + sz)\n          for(int lo = 0; lo < n - sz; lo += sz+sz)\n            // c语言没有min函数\n             Merge(a, lo, lo+sz-1; Math.min(lo+sz+sz-1, n-1));\n    }\n\n\tvoid Merge (int a[], int lo, int mid, int hi, int aux[])\n\t{\n\t\tint i = lo, j = mid + 1;\n\t\t//辅助变量\n\t\tint k;\n\t\tfor(k = lo; k <= hi; k++)\n\t\t{\n\t\t\taux[k] = a[k];\n\t\t}\n\n\t\tfor (k = lo; k <= hi; k++)\n\t\t\tif      (i > mid)           a[k] = aux[j++];\n\t\t\telse if (j > hi )           a[k] = aux[i++];\n\t\t\telse if (aux[j] < aux[i])   a[k] = aux[j++];\n\t\t\telse                        a[k] = aux[i++];\n\t}\n```\n","slug":"sorting","published":1,"updated":"2016-02-08T15:58:03.434Z","comments":1,"photos":[],"link":"","_id":"cike71t41000obya1wqg2hn98"},{"layout":"post","title":"os note","date":"2015-12-24T16:00:00.000Z","_content":"\n## Operating System  \n\n- virtualize CPU\n  - time sharing\n  - process\n      - machine state\n          - memory\n          - registers\n              - program counter\n              - instruction pointer\n              - frame pointer\n              - stack pointer\n      - process api\n          - create\n          - destroy\n          - wait\n          - miscellaneous control\n          - status\n  - question about process\n      - how does os get a program up and running?\n      - how does process creation actually work?\n  - process states\n      - Running\n      - Ready\n      - Blocked\n  - mechanism\n      - problem: how to perform restricted operations\n      - solution: use protected control transfer\n          - user mode\n          - kernel mode\n","source":"_posts/operating system.md","raw":"---\nlayout: post\ntitle: \"os note\"\ndate: 2015-12-25\ntags: note\n---\n\n## Operating System  \n\n- virtualize CPU\n  - time sharing\n  - process\n      - machine state\n          - memory\n          - registers\n              - program counter\n              - instruction pointer\n              - frame pointer\n              - stack pointer\n      - process api\n          - create\n          - destroy\n          - wait\n          - miscellaneous control\n          - status\n  - question about process\n      - how does os get a program up and running?\n      - how does process creation actually work?\n  - process states\n      - Running\n      - Ready\n      - Blocked\n  - mechanism\n      - problem: how to perform restricted operations\n      - solution: use protected control transfer\n          - user mode\n          - kernel mode\n","slug":"operating system","published":1,"updated":"2016-02-08T15:58:03.434Z","comments":1,"photos":[],"link":"","_id":"cike71t47000rbya1bsj848fo"},{"layout":"post","title":"台大Machine Learning笔记目录","_content":"- when can machines learn?  \n    - The Learning Problem  \n        - what is machine learning?  \n        - applications of machine learning  \n        - components of machine learning  \n        - machine learning and other fields  \n    - Learning to Answer Yes/No  \n        - Perceptron Hypothesis set  \n        - Perceptron Learning Algorithm(PLA)  \n        - Guarantee of PLA  \n        - Non-Separable Data  \n    - Types of Learning  \n        - Learning with Different Output Space Y  \n        - Learning with Different Data Label  \n        - Learning with Different Protocol f  \n        - Learning with Different Input Space X  \n    - Feasibility of Learning  \n        - Learning is Impossible?  \n        - Probability to the Rescue  \n        - Connection to Learning  \n        - Connection to Real Learning  \n- why can machines learn?  \n    - Training versus Testing\n        - Recap and Preview\n        - Effective Number of Lines\n        - Effective Number of Hypothesis\n        - Break Point\n\n- how can machines learn?  \n- how can machines learn better?   \n","source":"_posts/ml-index.md","raw":"---\nlayout: post\ntitle: 台大Machine Learning笔记目录\ntags: ml\ncategories: note\n---\n- when can machines learn?  \n    - The Learning Problem  \n        - what is machine learning?  \n        - applications of machine learning  \n        - components of machine learning  \n        - machine learning and other fields  \n    - Learning to Answer Yes/No  \n        - Perceptron Hypothesis set  \n        - Perceptron Learning Algorithm(PLA)  \n        - Guarantee of PLA  \n        - Non-Separable Data  \n    - Types of Learning  \n        - Learning with Different Output Space Y  \n        - Learning with Different Data Label  \n        - Learning with Different Protocol f  \n        - Learning with Different Input Space X  \n    - Feasibility of Learning  \n        - Learning is Impossible?  \n        - Probability to the Rescue  \n        - Connection to Learning  \n        - Connection to Real Learning  \n- why can machines learn?  \n    - Training versus Testing\n        - Recap and Preview\n        - Effective Number of Lines\n        - Effective Number of Hypothesis\n        - Break Point\n\n- how can machines learn?  \n- how can machines learn better?   \n","slug":"ml-index","published":1,"date":"2016-02-08T15:58:03.434Z","updated":"2016-02-08T15:58:03.434Z","comments":1,"photos":[],"link":"","_id":"cike71t4f000ubya1todi6gg2"},{"layout":"post","title":"vsftpd test","date":"2016-01-01T16:00:00.000Z","_content":"vsftpd:\n  /etc/vs....conf\n\nuseradd -d /home/ftp\n\npasswd username\npwd\n","source":"_posts/linux.md","raw":"---\nlayout: post\ntitle: vsftpd test\ndate: 2016-01-02\ntags: network\ncategories: note\n---\nvsftpd:\n  /etc/vs....conf\n\nuseradd -d /home/ftp\n\npasswd username\npwd\n","slug":"linux","published":1,"updated":"2016-02-08T15:58:03.434Z","comments":1,"photos":[],"link":"","_id":"cike71t4i000ybya15iizwhmr"},{"layout":"post","title":"上传文件时忽略某些文件或文件夹或特定类型的文件","date":"2016-02-07T16:00:00.000Z","_content":"\n在.gitignore中编辑\nexample:\n```\n#ignore database file, sln file, config file\n*.mdb\n*.ldb\n*.sln\n*.config\n\n#ignore fileFolder\nnode_modules\nDebug\n\n在具体的.gitignore文件中，也有详细的说明\n","source":"_posts/git上传.md","raw":"---\nlayout: post\ntitle: 上传文件时忽略某些文件或文件夹或特定类型的文件\ndate: 2016-02-08\ntags: git\ncategories: Be My Hero\n---\n\n在.gitignore中编辑\nexample:\n```\n#ignore database file, sln file, config file\n*.mdb\n*.ldb\n*.sln\n*.config\n\n#ignore fileFolder\nnode_modules\nDebug\n\n在具体的.gitignore文件中，也有详细的说明\n","slug":"git上传","published":1,"updated":"2016-02-08T16:16:06.283Z","comments":1,"photos":[],"link":"","_id":"cike71t4m0012bya1ao89f159"},{"layout":"post","title":"docker","date":"2016-01-03T16:00:00.000Z","_content":"1. docker理念：创建软件程序可移植的轻量容器\n2. docker功能:\n    - 隔离应用依赖\n    - 创建应用镜像并进行复制\n    - 创建容易分发的即启即用的应用\n    - 允许实例简单、快速的扩充\n    - 测试应用并随后销毁它们\n3. docker提供的资源和抽象，两个最重要的概念是镜像和容器\n    - 镜像\n","source":"_posts/docker.md","raw":"---\nlayout: post\ntitle: docker\ndate: 2016-01-04\ntags: docker\ncategories: note\n---\n1. docker理念：创建软件程序可移植的轻量容器\n2. docker功能:\n    - 隔离应用依赖\n    - 创建应用镜像并进行复制\n    - 创建容易分发的即启即用的应用\n    - 允许实例简单、快速的扩充\n    - 测试应用并随后销毁它们\n3. docker提供的资源和抽象，两个最重要的概念是镜像和容器\n    - 镜像\n","slug":"docker","published":1,"updated":"2016-02-08T15:58:03.434Z","comments":1,"photos":[],"link":"","_id":"cike71t4q0016bya154yp9w9p"},{"layout":"post","title":"Text Justification","date":"2016-02-05T16:00:00.000Z","_content":"\n\nGiven an array of words and a length L, format the text such that each line has exactly L characters and is fully (left and right) justified.\n\nYou should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' \\\\when necessary so that each line has exactly L characters.\n\nExtra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide \\\\evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\n\nFor the last line of text, it should be left justified and no extra space is inserted between words.\n\nFor example,\nwords: [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"]\nL: 16.\n\n```\npublic class Solution {\n    public static List<String> fullJustify(String[] words, int maxWidth) {\n        List<String> tmpList = new LinkedList<>();\n        List<String> resultList = new LinkedList<>();\n        String tmpResult = new String();\n        for (String str : words){\n            if(str.trim().length() > 0){\n                if((str + tmpResult + \" \").length() < maxWidth){\n                    str += \" \";\n                    tmpResult += str;\n                } else {\n                    tmpList.add(tmpResult);\n                }\n            }\n        }\n        if(tmpList.size() > 0){\n            for(String str : tmpList){\n                String[] tmpStr = str.split(\" \");\n                String tmpLine = new String();\n                String line = new String();\n                for (String word : tmpStr){\n                    tmpLine += word;\n                }\n                if(tmpList.size() > 1){\n                    int remainer = (maxWidth - tmpLine.length()) % (tmpStr.length - 1);\n                    int ava = (maxWidth - tmpLine.length()) / (tmpStr.length - 1);\n                    for(int i = 0; i < tmpStr.length; i++){\n                        String word = tmpStr[i];\n                        while(ava > 0){\n                            word += \" \";\n                            ava--;\n                        }\n                        if(i < remainer){\n                            word += \" \";\n                        }\n                        line += word;\n                    }\n                } else {\n                    int remainer = maxWidth - tmpLine.length();\n                    line = tmpStr[0];\n                    while(remainer-- > -1){\n                        line += \" \";\n                    }\n                }\n\n                resultList.add(line);\n            }\n        } else {\n            resultList.add(\"\");\n        }\n\n        return resultList;\n    }\n}\n```\n","source":"_posts/Text Justification.md","raw":"---\nlayout: post\ntitle: Text Justification\ndate: 2016-02-06\ntags: leetcode\ncategories: Be My Hero\n---\n\n\nGiven an array of words and a length L, format the text such that each line has exactly L characters and is fully (left and right) justified.\n\nYou should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' \\\\when necessary so that each line has exactly L characters.\n\nExtra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide \\\\evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\n\nFor the last line of text, it should be left justified and no extra space is inserted between words.\n\nFor example,\nwords: [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"]\nL: 16.\n\n```\npublic class Solution {\n    public static List<String> fullJustify(String[] words, int maxWidth) {\n        List<String> tmpList = new LinkedList<>();\n        List<String> resultList = new LinkedList<>();\n        String tmpResult = new String();\n        for (String str : words){\n            if(str.trim().length() > 0){\n                if((str + tmpResult + \" \").length() < maxWidth){\n                    str += \" \";\n                    tmpResult += str;\n                } else {\n                    tmpList.add(tmpResult);\n                }\n            }\n        }\n        if(tmpList.size() > 0){\n            for(String str : tmpList){\n                String[] tmpStr = str.split(\" \");\n                String tmpLine = new String();\n                String line = new String();\n                for (String word : tmpStr){\n                    tmpLine += word;\n                }\n                if(tmpList.size() > 1){\n                    int remainer = (maxWidth - tmpLine.length()) % (tmpStr.length - 1);\n                    int ava = (maxWidth - tmpLine.length()) / (tmpStr.length - 1);\n                    for(int i = 0; i < tmpStr.length; i++){\n                        String word = tmpStr[i];\n                        while(ava > 0){\n                            word += \" \";\n                            ava--;\n                        }\n                        if(i < remainer){\n                            word += \" \";\n                        }\n                        line += word;\n                    }\n                } else {\n                    int remainer = maxWidth - tmpLine.length();\n                    line = tmpStr[0];\n                    while(remainer-- > -1){\n                        line += \" \";\n                    }\n                }\n\n                resultList.add(line);\n            }\n        } else {\n            resultList.add(\"\");\n        }\n\n        return resultList;\n    }\n}\n```\n","slug":"Text Justification","published":1,"updated":"2016-02-08T16:03:33.648Z","comments":1,"photos":[],"link":"","_id":"cike71t4v001abya1pw1ejp0s"},{"layout":"post","title":"R language","date":"2016-01-17T16:00:00.000Z","_content":"\n\n## R language\n\n### atomic class of object\n\n- character\n- numeric(double precision real number)\n- integer(suffix L example:1L. It's explicitly an integer)\n- complex\n- logical\n\n### basic object : vector\n> vector can only contain objects of the same class\n\n- Inf(represent infinity example: 1/0)\n- NaN(not a number. eg: 0/0)\n\n\n### Attributes\nR objects can have attributes\n- name,dimnames\n- dimensions(e.g. matrices, arrays)\n- class\n- length\n- other user-defined attributes/metadata\nattributes of an objec can be accessed using the attributes().\n\n### Coercion\n\n#### Implicit\n\nExample:\n- `x <- c(\"TRUE\",\"a\",123)` --character  \n- `x<-c(TRUE,1,2,3)` --numeric  \n- `x<-c(TRUE,1L,2L,3L)` --integer  \n\n#### explicit\nExample: `x <- 0:6`  \n- `as.numeric(x)`  \n- `as.logical(x)`  \n- `as.character(x)`  \n\n### list\na special type of vector that can contain elements of different classes\n\n### matrices  \nevery element must be in the same class  \n`matrix(nrow = , ncol =  )`   \n`dim()`  \n`attributes()`  \n- upper left  \n  e.g.\n  - `m <- matrix(1:6, nrow = 2, ncol = 3)`  \n  - `m <- 1:6`  \n    `dim(m) <- c(2,3)`  \n- cbind() and rbind()  \n\n### Factors   \n`x <- factor(c(\"yes\",\"yes\",\"no\",\"yes\"))`  \n\n### Missing Values  \n- `is.na()` NA has class  \n- `is.nan()` NAN is also a NA\n\n### data frame  \ncan have different classes of objects in each column  \nspecial attributes:  \n- row.names  \n- created by calling `read.csv()` or `read.table()`  \n- converted to a matrix by calling data.matrix()  \n\n### name attribute  \n\n- vector  \n`x <- 1:3`  \n`names(x) <- c(\"a\",\"b\",\"c\")`\n\n| a | b |c|\n|:--|:--|:--|\n| 1 |2 | 3 |\n\n- matrix  \n`m <- matrix(1:4, nrow = 2, ncol = 2)`  \n`dimnames(m) <- list(c(\"a\",\"b\"),c(\"c\",\"d\"))`\n\n||c|d|\n|:--|:--|:--|\n|a|1|3|\n|b|2|4|\n","source":"_posts/R-language.md","raw":"---\nlayout: post\ntitle: R language\ndate: 2016-01-18\ntags:\n- R\ncategories: note\n---\n\n\n## R language\n\n### atomic class of object\n\n- character\n- numeric(double precision real number)\n- integer(suffix L example:1L. It's explicitly an integer)\n- complex\n- logical\n\n### basic object : vector\n> vector can only contain objects of the same class\n\n- Inf(represent infinity example: 1/0)\n- NaN(not a number. eg: 0/0)\n\n\n### Attributes\nR objects can have attributes\n- name,dimnames\n- dimensions(e.g. matrices, arrays)\n- class\n- length\n- other user-defined attributes/metadata\nattributes of an objec can be accessed using the attributes().\n\n### Coercion\n\n#### Implicit\n\nExample:\n- `x <- c(\"TRUE\",\"a\",123)` --character  \n- `x<-c(TRUE,1,2,3)` --numeric  \n- `x<-c(TRUE,1L,2L,3L)` --integer  \n\n#### explicit\nExample: `x <- 0:6`  \n- `as.numeric(x)`  \n- `as.logical(x)`  \n- `as.character(x)`  \n\n### list\na special type of vector that can contain elements of different classes\n\n### matrices  \nevery element must be in the same class  \n`matrix(nrow = , ncol =  )`   \n`dim()`  \n`attributes()`  \n- upper left  \n  e.g.\n  - `m <- matrix(1:6, nrow = 2, ncol = 3)`  \n  - `m <- 1:6`  \n    `dim(m) <- c(2,3)`  \n- cbind() and rbind()  \n\n### Factors   \n`x <- factor(c(\"yes\",\"yes\",\"no\",\"yes\"))`  \n\n### Missing Values  \n- `is.na()` NA has class  \n- `is.nan()` NAN is also a NA\n\n### data frame  \ncan have different classes of objects in each column  \nspecial attributes:  \n- row.names  \n- created by calling `read.csv()` or `read.table()`  \n- converted to a matrix by calling data.matrix()  \n\n### name attribute  \n\n- vector  \n`x <- 1:3`  \n`names(x) <- c(\"a\",\"b\",\"c\")`\n\n| a | b |c|\n|:--|:--|:--|\n| 1 |2 | 3 |\n\n- matrix  \n`m <- matrix(1:4, nrow = 2, ncol = 2)`  \n`dimnames(m) <- list(c(\"a\",\"b\"),c(\"c\",\"d\"))`\n\n||c|d|\n|:--|:--|:--|\n|a|1|3|\n|b|2|4|\n","slug":"R-language","published":1,"updated":"2016-02-08T15:58:03.434Z","comments":1,"photos":[],"link":"","_id":"cike71t50001ebya1f9j7y4tw"},{"layout":"post","title":"python学习","date":"2016-01-05T16:00:00.000Z","_content":"\n### python学习\n- 学习一门语言，应该知道\n    - 基础数据类型\n    - 基本的流程控制\n    - 数据结构\n- 尝试写一个程序时，需要知道如何做简单的输入和输出。\n    - 输入\n        1. 从文件读取数据\n        2. 从键盘读取数据\n    - 输出\n        1. 将结果显示在屏幕上\n        2. 将结果输出到文件中\n\n> 鉴于时间间隔太大，先回忆下自己学过哪些\n\n1. 数据类型\n    - number\n        - +,-,*,/,//,%\n        - **,round\n    - string\n        - index\n        - slice\n        - +\n        - ('' '')\n2. 数据结构\n    - del statement\n    - list[]\n        - index\n        - slice\n        - append = a.[len(a):] = [x]\n        - nest list\n        - extend = a.[len(a):] = L\n        - insert\n        - remove\n        - pop\n        - clear\n        - sort\n        - reverse\n        - copy\n        - count\n    - tuple()\n    - set{}\n    - dictionary{,}\n    - sequence[]\n3. 控制语句\n    - if\n        - if...elif..else\n    - for\n        - for ... in ...\n        - for i in range(5)\n    - break,continue\n    - else on loops\n    - pass\n    - define\n    - Defining Functions\n\n\n```\nf = open('xxx','r')\ndata = f.read()\n\nnew_data = data.split(',')\n```\n","source":"_posts/PythonLearning1.md","raw":"---\nlayout: post\ntitle: python学习\ndate: 2016-01-06\ntags: python\ncategories: note\n---\n\n### python学习\n- 学习一门语言，应该知道\n    - 基础数据类型\n    - 基本的流程控制\n    - 数据结构\n- 尝试写一个程序时，需要知道如何做简单的输入和输出。\n    - 输入\n        1. 从文件读取数据\n        2. 从键盘读取数据\n    - 输出\n        1. 将结果显示在屏幕上\n        2. 将结果输出到文件中\n\n> 鉴于时间间隔太大，先回忆下自己学过哪些\n\n1. 数据类型\n    - number\n        - +,-,*,/,//,%\n        - **,round\n    - string\n        - index\n        - slice\n        - +\n        - ('' '')\n2. 数据结构\n    - del statement\n    - list[]\n        - index\n        - slice\n        - append = a.[len(a):] = [x]\n        - nest list\n        - extend = a.[len(a):] = L\n        - insert\n        - remove\n        - pop\n        - clear\n        - sort\n        - reverse\n        - copy\n        - count\n    - tuple()\n    - set{}\n    - dictionary{,}\n    - sequence[]\n3. 控制语句\n    - if\n        - if...elif..else\n    - for\n        - for ... in ...\n        - for i in range(5)\n    - break,continue\n    - else on loops\n    - pass\n    - define\n    - Defining Functions\n\n\n```\nf = open('xxx','r')\ndata = f.read()\n\nnew_data = data.split(',')\n```\n","slug":"PythonLearning1","published":1,"updated":"2016-02-08T15:58:03.434Z","comments":1,"photos":[],"link":"","_id":"cike71t52001ibya1dm5bydoz"},{"layout":"post","title":"Propertys and Bindings","date":"2015-07-02T16:00:00.000Z","_content":"\n## I need to know\n- What is a Property?\n- How to create a property object and use it.\n- The class hierarchy of properties in javafx\n- How to handle the invalidation and change events in a property object\n- What a bingding is in JavaFx and how to use unidirectional an bidirectional bindings.\n- About the high-level and low-level bingdings API in JavaFX\n","source":"_posts/JavaFx-Property-and-Bindings.md","raw":"---\nlayout: post\ntitle: Propertys and Bindings\ndate: 2015-07-03\ntags: JavaFx\ncategories: note\n---\n\n## I need to know\n- What is a Property?\n- How to create a property object and use it.\n- The class hierarchy of properties in javafx\n- How to handle the invalidation and change events in a property object\n- What a bingding is in JavaFx and how to use unidirectional an bidirectional bindings.\n- About the high-level and low-level bingdings API in JavaFX\n","slug":"JavaFx-Property-and-Bindings","published":1,"updated":"2016-02-08T15:58:03.434Z","comments":1,"photos":[],"link":"","_id":"cike71t54001mbya1e2gcsh2w"}],"PostAsset":[],"PostCategory":[{"post_id":"cike71t300000bya1r7ajrj50","category_id":"cike71t360001bya1qtjbqwq6","_id":"cike71t3a0004bya1s9e70mzo"},{"post_id":"cike71t3l0008bya1nwgsrb5n","category_id":"cike71t3n0009bya1uj2ulqnm","_id":"cike71t3o000cbya1dmj2a2z0"},{"post_id":"cike71t3s000gbya1u3m0zbk9","category_id":"cike71t3n0009bya1uj2ulqnm","_id":"cike71t3u000hbya16pxk1e45"},{"post_id":"cike71t3x000jbya11mybcph6","category_id":"cike71t3y000kbya19q5jatcq","_id":"cike71t3z000nbya13f5k756x"},{"post_id":"cike71t4f000ubya1todi6gg2","category_id":"cike71t360001bya1qtjbqwq6","_id":"cike71t4g000vbya1xu2stf8b"},{"post_id":"cike71t4i000ybya15iizwhmr","category_id":"cike71t360001bya1qtjbqwq6","_id":"cike71t4k000zbya1rxol9qwy"},{"post_id":"cike71t4m0012bya1ao89f159","category_id":"cike71t3y000kbya19q5jatcq","_id":"cike71t4o0013bya1crxbhj1v"},{"post_id":"cike71t4q0016bya154yp9w9p","category_id":"cike71t360001bya1qtjbqwq6","_id":"cike71t4r0017bya194f2xcq3"},{"post_id":"cike71t4v001abya1pw1ejp0s","category_id":"cike71t3y000kbya19q5jatcq","_id":"cike71t4x001bbya1xi2qx8bq"},{"post_id":"cike71t50001ebya1f9j7y4tw","category_id":"cike71t360001bya1qtjbqwq6","_id":"cike71t51001fbya1jptw9uaf"},{"post_id":"cike71t52001ibya1dm5bydoz","category_id":"cike71t360001bya1qtjbqwq6","_id":"cike71t53001jbya1sc0tqsm1"},{"post_id":"cike71t54001mbya1e2gcsh2w","category_id":"cike71t360001bya1qtjbqwq6","_id":"cike71t55001nbya10ob1c2c7"}],"PostTag":[{"post_id":"cike71t300000bya1r7ajrj50","tag_id":"cike71t360002bya11aa5z676","_id":"cike71t3a0003bya1erfagkdo"},{"post_id":"cike71t3l0008bya1nwgsrb5n","tag_id":"cike71t3n000abya1hxb7r0h7","_id":"cike71t3n000bbya18mqx3qb3"},{"post_id":"cike71t3p000dbya1kz1j061r","tag_id":"cike71t3q000ebya12jkjsdj1","_id":"cike71t3r000fbya1er3z089g"},{"post_id":"cike71t3s000gbya1u3m0zbk9","tag_id":"cike71t3q000ebya12jkjsdj1","_id":"cike71t3v000ibya17109ue8w"},{"post_id":"cike71t3x000jbya11mybcph6","tag_id":"cike71t3y000lbya1k2hsg02r","_id":"cike71t3z000mbya1a4so6pr1"},{"post_id":"cike71t41000obya1wqg2hn98","tag_id":"cike71t43000pbya1st9ximq3","_id":"cike71t44000qbya1btnmql17"},{"post_id":"cike71t47000rbya1bsj848fo","tag_id":"cike71t49000sbya1omgadpd2","_id":"cike71t4a000tbya1s4lb54xj"},{"post_id":"cike71t4f000ubya1todi6gg2","tag_id":"cike71t4g000wbya1amg4oxji","_id":"cike71t4g000xbya1hstc1qm2"},{"post_id":"cike71t4i000ybya15iizwhmr","tag_id":"cike71t4k0010bya159n25tay","_id":"cike71t4l0011bya1v8h4osbr"},{"post_id":"cike71t4m0012bya1ao89f159","tag_id":"cike71t4p0014bya11qdiul8l","_id":"cike71t4p0015bya1e9bbf2x6"},{"post_id":"cike71t4q0016bya154yp9w9p","tag_id":"cike71t4s0018bya1k717m9ax","_id":"cike71t4u0019bya1upvr7dxd"},{"post_id":"cike71t4v001abya1pw1ejp0s","tag_id":"cike71t4x001cbya1e9rprlr1","_id":"cike71t4y001dbya1ym403czv"},{"post_id":"cike71t50001ebya1f9j7y4tw","tag_id":"cike71t51001gbya1ups8qg6q","_id":"cike71t51001hbya12gtkqxc7"},{"post_id":"cike71t52001ibya1dm5bydoz","tag_id":"cike71t53001kbya1tmsylzhn","_id":"cike71t54001lbya16xv89apk"},{"post_id":"cike71t54001mbya1e2gcsh2w","tag_id":"cike71t55001obya1dks4uwj7","_id":"cike71t57001pbya1ksum1w0k"}],"Tag":[{"name":"Java","_id":"cike71t360002bya11aa5z676"},{"name":"书单","_id":"cike71t3n000abya1hxb7r0h7"},{"name":"随笔","_id":"cike71t3q000ebya12jkjsdj1"},{"name":"tar","_id":"cike71t3y000lbya1k2hsg02r"},{"name":"算法","_id":"cike71t43000pbya1st9ximq3"},{"name":"note","_id":"cike71t49000sbya1omgadpd2"},{"name":"ml","_id":"cike71t4g000wbya1amg4oxji"},{"name":"network","_id":"cike71t4k0010bya159n25tay"},{"name":"git","_id":"cike71t4p0014bya11qdiul8l"},{"name":"docker","_id":"cike71t4s0018bya1k717m9ax"},{"name":"leetcode","_id":"cike71t4x001cbya1e9rprlr1"},{"name":"R","_id":"cike71t51001gbya1ups8qg6q"},{"name":"python","_id":"cike71t53001kbya1tmsylzhn"},{"name":"JavaFx","_id":"cike71t55001obya1dks4uwj7"}]}}