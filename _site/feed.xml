<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>GoBraves Blog</title>
    <description>To be my hero</description>
    <link>http://yourdomain.com/</link>
    <atom:link href="http://yourdomain.com/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sat, 11 Jul 2015 20:16:47 +0800</pubDate>
    <lastBuildDate>Sat, 11 Jul 2015 20:16:47 +0800</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>输入/输出</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;输入/输出&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;文件系统和路径&lt;/li&gt;
  &lt;li&gt;文件和目录的处理及操作&lt;/li&gt;
  &lt;li&gt;输入/输出流&lt;/li&gt;
  &lt;li&gt;读取二进制数据&lt;/li&gt;
  &lt;li&gt;写入二进制数据&lt;/li&gt;
  &lt;li&gt;写入文本&lt;/li&gt;
  &lt;li&gt;读取文本&lt;/li&gt;
  &lt;li&gt;用PrintStream记录日志&lt;/li&gt;
  &lt;li&gt;随机访问文件&lt;/li&gt;
  &lt;li&gt;对象序列化&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;section-1&quot;&gt;1.文件系统和路径&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;文件系统中的对象可以用一条路径作为惟一的识别&lt;/li&gt;
  &lt;li&gt;路径分为绝对路径和相对路径&lt;/li&gt;
  &lt;li&gt;文件或者目录一般用java.io.File对象表示，java7中，用java.nio.file.Path接口代替它 &lt;br /&gt;
&amp;gt; FileSystem类 :
  &amp;gt;  - &lt;code&gt;FileSystems.getDefault()&lt;/code&gt;获取当前的文件系统 &lt;br /&gt;
  &amp;gt;  - &lt;code&gt;getSeparator()&lt;/code&gt;获取当前系统的分隔符 &lt;br /&gt;
  &amp;gt;  - &lt;code&gt;getRootDirectories()&lt;/code&gt;返回一个Iterable,遍历根目录&lt;/li&gt;
  &lt;li&gt;创建path
    &lt;ol&gt;
      &lt;li&gt;&lt;code&gt;FileSystems.getPath(...)&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;Path path = Paths.get(...)&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;getNameCount()&lt;/code&gt;,&lt;code&gt;getName(int index)&lt;/code&gt;从0开始&lt;/li&gt;
      &lt;li&gt;path其他方法&lt;code&gt;getFileName()&lt;/code&gt;,&lt;code&gt;getParent()&lt;/code&gt;,&lt;code&gt;getRoot()&lt;/code&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;section-2&quot;&gt;2.文件和目录的处理及操作&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;创建和删除文件及目录 &lt;br /&gt;
&lt;code&gt;createFile()&lt;/code&gt;,&lt;code&gt;createDirectory()&lt;/code&gt;,&lt;code&gt;delete()&lt;/code&gt;,&lt;code&gt;deleteIfExists()&lt;/code&gt;,如果用&lt;code&gt;delteIfExists()&lt;/code&gt;删除目录，则目录必须为空&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;获取目录的对象&lt;br /&gt;
使用newDirectoryStream()方法,&lt;code&gt;public static DirectoryStream&amp;lt;Path&amp;gt; newDirectoryStream(Path path)&lt;/code&gt;&lt;br /&gt;
—
&amp;gt;  代码实例：&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;pre&gt;&lt;code&gt;    Path parent = Paths.get(&quot;/home/simple_chen/下载&quot;);
 	try (DirectoryStream&amp;lt;Path&amp;gt; children = Files.newDirectoryStream(parent)){
 	  for (Path child : children) {
    	  System.out.println(child);
       }
     } catch (IOException e) {
      		e.printStackTrace();
     }    ---        
&lt;/code&gt;&lt;/pre&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;复制和文件移动
    &lt;ol&gt;
      &lt;li&gt;复制
    &lt;code&gt;public static Path copy(Path source, Path target, CopyOption...options) throws java.io.IOException&lt;/code&gt; &lt;br /&gt;
    CopyOption是java.nio.file包的一个接口。&lt;code&gt;StandardCopyOption&lt;/code&gt;是CopyOption接口的一个实现。&lt;br /&gt;
    StandardCopyOption有三个复制选项:
        &lt;ul&gt;
          &lt;li&gt;ATOMIC_MOVE&lt;/li&gt;
          &lt;li&gt;COPY_ATTRIBUTES&lt;/li&gt;
          &lt;li&gt;REPLACE_EXISTING&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;移动
&lt;code&gt;public static Path move(Path source, Path target, CopyOption...options) throws java.io.IOException&lt;/code&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;文件读取和写入
 对于较小的文件，File类提供了从二进制文件和文本文件读取和写入的方法
    &lt;ul&gt;
      &lt;li&gt;二进制&lt;br /&gt;
 &lt;code&gt;public static byte[] readAllBytes(Path path) throws java.io.IOException&lt;/code&gt;&lt;br /&gt;
 &lt;code&gt;public static write(Path path, byte[] bytes, OpenOption...options) throws java.io.IOException&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;文本文件&lt;br /&gt;
 &lt;code&gt;public static List&amp;lt;String&amp;gt; readAllLines(Path path, java.nio.charset.Charset charset) throws java.io.IOException&lt;/code&gt;
 &lt;code&gt;public static write(Path path, java.lang.Iterable&amp;lt;? extends CharSequence&amp;gt; lines, java.nio.charset.Charset charset, OpenOption...options) throws java.io.IOException&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;这两个方法都重载了OpenOption,第二个方法还重载了一个Charset&lt;/p&gt;

      &lt;ul&gt;
        &lt;li&gt;StandardOpenOption实现了OpenOption接口:
          &lt;ul&gt;
            &lt;li&gt;APPEND&lt;/li&gt;
            &lt;li&gt;CREATE&lt;/li&gt;
            &lt;li&gt;CREATE_NEW&lt;/li&gt;
            &lt;li&gt;DELETE_ON_CLOSE&lt;/li&gt;
            &lt;li&gt;DSYNC&lt;/li&gt;
            &lt;li&gt;READ&lt;/li&gt;
            &lt;li&gt;SPARSE&lt;/li&gt;
            &lt;li&gt;SYNC&lt;/li&gt;
            &lt;li&gt;TRUNCATE_EXISTING&lt;/li&gt;
            &lt;li&gt;WRITE&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/blockquote&gt;

    &lt;blockquote&gt;
      &lt;ul&gt;
        &lt;li&gt;java.nio.charset.Charset是一个表示字符集的抽象类。需要指定在将&lt;strong&gt;字符编码成字节&lt;/strong&gt;和将&lt;strong&gt;字节解码成字符&lt;/strong&gt;时要使用的字符集。
 创建一个charset &lt;br /&gt;
 &lt;code&gt;Charset usAscii = Charset.forName(&quot;US-ASCII&quot;)&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/blockquote&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;代码实例:&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

      &lt;pre&gt;&lt;code&gt; 	Path textfile = Paths.get(&quot;/home/simple_chen/textfile&quot;);
 	Charset charset = Charset.forName(&quot;US-ASCII&quot;);
 	String line1 = &quot;Easy read and write&quot;;
 	String line2 = &quot;Easy read and write&quot;;
 	List&amp;lt;String&amp;gt; lines = Arrays.asList(line1,line2);
 	try {
     	Files.write(textfile,lines,charset);
 	} catch (IOException e) {
     	e.printStackTrace();
 	}  

 	List&amp;lt;String&amp;gt; linesRead = null;
 	try {
     	linesRead = Files.readAllLines(textfile, charset);
 	} catch (IOException e) {
     	e.printStackTrace();
 	}  

 	if(linesRead != null) {
     	for (String str : linesRead) {
         	System.out.println(str);
     	}
 	}	   
&lt;/code&gt;&lt;/pre&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;section-3&quot;&gt;3. 输入/输出流&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;What is Stream?&lt;br /&gt;
个人理解：用一种统一的方式使的数据在不同的接收装置中传输的机制吧。打个比方，流就是管道，接收装置就是一个个“水库”，而管道将各个水库连接起来。&lt;/li&gt;
  &lt;li&gt;流的分类&lt;br /&gt;
根据数据流向，可分为输入流和输出流，而数据又可以分为二进制数据和字符，因此每种又可分为两种，即：
         - Reader: 从一个接收装置中读取字符的流
         - Writer: 将一个字符写入一个接收装置的流
         - InputStream: 从一个接收装置中读取二进制数据的流
         - OutputStream: 将二进制数据写入到一个接收装置的流&lt;/li&gt;
  &lt;li&gt;流的一般操作顺序：
         1. 创建一个流。得到的对象已经处于打开状态，因此没有open方法可以调用
         2. 执行读取或者写入操作
         3. 通过调用close方法关闭流。由于当前大多数流都实现了java.lang.AutoCloseable接口，因此可以利用try-with-resources语句创建一个流，并且让流自动关闭&lt;/li&gt;
  &lt;li&gt;使用流的好处
 			1. 为数据的读取和写入定义了方法，无论数据源还是数据目标都可以使用。
 			2. 为了连接一个专门的接收装置，利用java.nio.file.Files类提供的方法，正确构造流即可。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;section-4&quot;&gt;4. 读取二进制数据&lt;/h4&gt;

</description>
        <pubDate>Sat, 04 Jul 2015 00:00:00 +0800</pubDate>
        <link>http://yourdomain.com/java/2015/07/04/Java-io/</link>
        <guid isPermaLink="true">http://yourdomain.com/java/2015/07/04/Java-io/</guid>
        
        
        <category>java</category>
        
      </item>
    
      <item>
        <title>Propertys and Bindings</title>
        <description>&lt;h2 id=&quot;i-need-to-know&quot;&gt;I need to know&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;What is a Property?&lt;/li&gt;
  &lt;li&gt;How to create a property object and use it.&lt;/li&gt;
  &lt;li&gt;The class hierarchy of properties in javafx&lt;/li&gt;
  &lt;li&gt;How to handle the invalidation and change events in a property object&lt;/li&gt;
  &lt;li&gt;What a bingding is in JavaFx and how to use unidirectional an bidirectional bindings.&lt;/li&gt;
  &lt;li&gt;About the high-level and low-level bingdings API in JavaFX&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 03 Jul 2015 00:00:00 +0800</pubDate>
        <link>http://yourdomain.com/javafx/2015/07/03/JavaFx-Property-and-Bindings/</link>
        <guid isPermaLink="true">http://yourdomain.com/javafx/2015/07/03/JavaFx-Property-and-Bindings/</guid>
        
        
        <category>javafx</category>
        
      </item>
    
      <item>
        <title>排序整理</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;冒泡排序&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;选择排序&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;插入排序&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;希尔排序&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;快速排序&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#edition&quot; id=&quot;markdown-toc-edition&quot;&gt;1 edition&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#edition-1&quot; id=&quot;markdown-toc-edition-1&quot;&gt;2 edition&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#edition-2&quot; id=&quot;markdown-toc-edition-2&quot;&gt;3 edition&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;归并排序&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
  &lt;p&gt;《算法》第四版复习整理（c语言）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;void swap(int &amp;amp;i, int &amp;amp;j) 
{
	int temp = i;
	i = j;
	j = temp; 
}    
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section&quot;&gt;冒泡排序&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;void BubbleSort(int a[], int n) 
{
	for(int i = 0; i &amp;lt; n; i++)  
		for (int j = 1; j &amp;lt; n - i; ++j)  
		{
			if(a[j-1] &amp;gt; a[j]) 
			{	
				swap(a[j-1],a[j]);
			}
		}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;选择排序&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;void SelectSort(int a[], int n) 
{
	int i,j,min;
	int temp;
	for (i = 0; i &amp;lt; n; ++i)
	{
		min = i;
		for (j = i+1; j &amp;lt; n; ++j)
		{
			if (a[min] &amp;gt; a[j])
			min = j;
		}
		swap(a[i],a[min]);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-2&quot;&gt;插入排序&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;void InsertSort(int a[], int n)
{
	int i,j;
	for (int i = 0; i &amp;lt; n; ++i)
	{
		for (int j = i; j &amp;gt; 0 &amp;amp;&amp;amp; (a[j] &amp;lt; a[j-1]) ; --j)
		swap(a[j],a[j-1]);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-3&quot;&gt;希尔排序&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;void ShellSort(int a[], int n) 
{
	int h = 1;
	int i,j;
	while(h &amp;lt; n/3)
	h = 3*h + 1;
	while(h &amp;gt;= 1) 
	{
		for (i = h; i &amp;lt; n; ++i)
		{
			for (j = i; j &amp;gt;= h &amp;amp;&amp;amp; (a[j] &amp;lt; a[j-h]); j -= h)
			swap(a[j],a[j-h]);
		}	
		h = h/3;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-4&quot;&gt;快速排序&lt;/h2&gt;

&lt;h3 id=&quot;edition&quot;&gt;1 edition&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;	void QuickSort(int v[], int left, int right) 
	{
		int i, last;
		if (left &amp;gt;= right)
			return;
		swap(v[left], v[(left+right)/2]);
			last = left;
		for (i = 0; i &amp;lt; right; ++i)
			if (v[i] &amp;lt; v[left])
				swap(++last, i);
		swap(left,last);
		QuickSort(v,left,last-1);
		QuickSort(v,last+1,right);
	}  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;edition-1&quot;&gt;2 edition&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;	void QuickSort(int a[], int n) 
	{
		//1.random shuffle 消除对输入的依赖
		//2.Sort(a,0,n-1);
   	 	}

	void Sort(int a[], int lo, int hi)
	{
		if (hi &amp;gt; lo)
		{
			int j = partition(a, lo, hi);
			sort(a, lo, j-1);
			sort(a, j+1, hi);
		}
	}

	int partition(int a[], int lo, int hi) 
	{
   		// hi + 1 是一个技巧
   		int i = lo, j = hi+1;
   		int v = a[lo];
   		while(true) 
   		{
   		while (a[++i] &amp;lt; v) 
   		if (i == hi)
   		break;
   		while (v &amp;lt; a[--j])
   		if (j == lo) 
   		break;
   		if (i &amp;gt;= j)
   		break;
   		swap(a[i],a[j]); 
    	}
   		swap(a[lo],a[j]);
   		return j;
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;edition-2&quot;&gt;3 edition&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;	void QuickSort(int a[], int lo, int hi) 
	{
		int i = lo, j = hi; 
		int temp;
		if (hi &amp;gt; lo)
		{
			temp = a[lo];
			while (i != j)
			{
				while (j &amp;gt; i &amp;amp;&amp;amp; a[j] &amp;gt;= temp)
				{
				j--;
				}
				a[i] = a[j];
				while (i &amp;lt; j &amp;amp;&amp;amp; a[i] &amp;lt;= temp)
				{
					i++;
				}
				a[j] = a[i];
			}
			a[i] = temp;
			QuickSort(a, lo , i - 1);
			QuickSort(a, i + 1, hi);
		}	
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;版本2和版本3的区别在于，版本2的是让两边同时进行比较，在两边都不符合条件的情况下交换，直至i和j相等。版本3若是右边一边比较不符合条件，则移至另一边比较，直至i和j相等。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-5&quot;&gt;归并排序&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;bool MergeSort(int a[], int n); 
{
   int aux[n];
 	   sort(a,0,n-1,aux);
 	   return true;
} 

//自底向下
void Sort(int a[], int lo, int hi,int aux[])
{
   if (hi &amp;gt; lo) 
   {
   	  int mid = lo + (hi - lo)/2;
   	  Sort(a, lo, mid);
   	  Sort(a, mid+1, hi);
   	  Merge(a, lo, mid, hi, aux);
   }
}

//自底向上
void Sort(int a[], int n, int aux)
{
   for(int sz = 1; sz &amp;lt; n; sz = sz + sz)
      for(int lo = 0; lo &amp;lt; n - sz; lo += sz+sz)
        // c语言没有min函数
         Merge(a, lo, lo+sz-1; Math.min(lo+sz+sz-1, n-1));
}

void Merge (int a[], int lo, int mid, int hi, int aux[])
{	
	int i = lo, j = mid + 1;
	//辅助变量
	int k;
	for(k = lo; k &amp;lt;= hi; k++)
	{
		aux[k] = a[k];
	}

	for (k = lo; k &amp;lt;= hi; k++) 
		if      (i &amp;gt; mid)           a[k] = aux[j++];
		else if (j &amp;gt; hi )           a[k] = aux[i++];
		else if (aux[j] &amp;lt; aux[i])   a[k] = aux[j++];
		else                        a[k] = aux[i++];
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Mon, 22 Jun 2015 00:00:00 +0800</pubDate>
        <link>http://yourdomain.com/%E7%AE%97%E6%B3%95/2015/06/22/sorting/</link>
        <guid isPermaLink="true">http://yourdomain.com/%E7%AE%97%E6%B3%95/2015/06/22/sorting/</guid>
        
        
        <category>算法</category>
        
      </item>
    
      <item>
        <title>My first journal</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#test&quot; id=&quot;markdown-toc-test&quot;&gt;test&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;test&quot;&gt;test&lt;/h2&gt;

</description>
        <pubDate>Sun, 21 Jun 2015 18:17:00 +0800</pubDate>
        <link>http://yourdomain.com/diary/2015/06/21/My-first-journal/</link>
        <guid isPermaLink="true">http://yourdomain.com/diary/2015/06/21/My-first-journal/</guid>
        
        
        <category>diary</category>
        
      </item>
    
  </channel>
</rss>
